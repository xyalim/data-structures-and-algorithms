

事前估算分析方法 #flashcards 
?
![[不能用绝对执行时间进行比较的原因]]
撇开上述因素，认为算法的执行时间是 [[#问题规模n]] 的函数。
<!--ID: 1706000488188-->






## 算法的执行时间用时间复杂度来表示
算法中执行时间T(n)是问题规模n的某个函数f(n)，记作：$T(n) = O(f(n))$
记号“O”读作“大O”，它表示随问题规模 n 的增大算法执行时间的增长率和 f(n) 的增长率相同。 $\Rightarrow$  趋势分析
![[事前估算分析方法-图.png]]

#flashcards “O”的形式定义为：
?
$T(n) = O(f(n))$ 表示存在一个正的常数 $M$，使得当 $n \geqslant n_{0}$  时都满足：$|T(n)| \leqslant M |f(n)|$
其中 $f(n)$ 是 $T(n)$  的上界, 这种上界可能很多, 通常取得接近的上界, 即==紧凑上界==.
大致情况:  $\lim_{x \to \infty} \frac{T(n)}{f(n)} = M$  

也就是只求出T(n)的最高阶，忽略其低阶项和常系数，这样既可简化T(n)的计算，又能比较客观地反映出当n很大时算法的时间性能。

例如 ：$T(n) = 2n^2+2n+1 = O(n^2)$

> [!一般地]
> - 一个没有循环的算法的执行时间与问题规模n无关，记作$O(1)$，也称作==常数阶==。
> - 一个只有一重循环的算法的执行时间与问题规模n的增长呈线性增大关系，记作$O(n)$，也称==线性阶==。
> - 其余常用的算法时间复杂度还有==平方阶==$O(n2)$、==立方阶==$O(n3)$、==对数阶==$O(log_{2}n)$、==指数阶==$O(2^n)$等。


## 各种不同算法时间复杂度的比较关系

#flashcards 
?
$\overset{\underbrace{O(1)<O(log_{2}n)<O(n)<O(nlog_{2}n)<O(n^{2})<O(n^{3})}}{多项式阶: P问题} \overset{\underbrace{<O(2^n)<O(n!)}}{指数阶NP问题}$
NP = P ? 是目前计算机科学的难题之一。


![[例题3]]