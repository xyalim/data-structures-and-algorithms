TARGET DECK
数据结构与算法

事前估算分析方法 #flashcards 
?
撇开上述因素，认为算法的执行时间是 [[#问题规模n]] 的函数。
<!--ID: 1705921777217-->


## 具体分析步骤

#flashcards 
?
> [!具体分析步骤]
> - 求出算法所有原操作的执行次数（也称为频度） ，它是问题规模n的函数，用T(n)表示。
> - 算法执行时间大致 = 原操作所需的时间 $\times$ T(n)。所以T(n)与算法的执行时间成正比 。为此用T(n)表示算法的执行时间。
> - 比较不同算法的T(n)大小得出算法执行时间的好坏。
---

## 问题规模n

用于表示求解问题大小的正整数，如n个记录排序


e.g.
```c
#define MAX   20    //定义最大的方阶
void matrixadd(int n, int A[MAX][MAX], int B[MAX][MAX], int C[MAX][MAX]){
	int i, j;
   	for (i=0; i<n; i++)				//①
		for (j=0; j<n; j++)			//②
			C[i][j]=A[i][j]+B[i][j];	//③ 
}

```

① 频度为 $n + 1$ , 循环体执行 n 次
② 频度为 $n (n+1)$
③ 频度为 $n^2$

所有语句频度之和为: $T(n) =  n+1+n(n+1)+n^2 =  2n^2+2n+1$

## 用时间复杂度来表示

算法中执行时间T(n)是问题规模n的某个函数f(n)，记作：$T(n) = O(f(n))$
记号“O”读作“大O”，它表示随问题规模 n 的增大算法执行时间的增长率和 f(n) 的增长率相同。 $\Rightarrow$  趋势分析
![[事前估算分析方法-图.png]]

#flashcards “O”的形式定义为：
?
$T(n) = O(f(n))$ 表示存在一个正的常数 $M$，使得当 $n \geqslant n_{0}$  时都满足：$|T(n)| \leqslant M |f(n)|$
其中 $f(n)$ 是 $T(n)$  的上界, 这种上界可能很多, 通常取得接近的上界, 即==紧凑上界==.
大致情况:  $\lim_{x \to \infty} \frac{T(n)}{f(n)} = M$  

也就是只求出T(n)的最高阶，忽略其低阶项和常系数，这样既可简化T(n)的计算，又能比较客观地反映出当n很大时算法的时间性能。

例如 ：$T(n) = 2n^2+2n+1 = O(n^2)$

> [!一般地]
> - 一个没有循环的算法的执行时间与问题规模n无关，记作$O(1)$，也称作==常数阶==。
> - 一个只有一重循环的算法的执行时间与问题规模n的增长呈线性增大关系，记作$O(n)$，也称==线性阶==。
> - 其余常用的算法时间复杂度还有==平方阶==$O(n2)$、==立方阶==$O(n3)$、==对数阶==$O(log_{2}n)$、==指数阶==$O(2^n)$等。


## 各种不同算法时间复杂度的比较关系

#flashcards/cc
? 
$O(1)<O(log_{2}n)<O(n)<O(nlog_{2}n)<O(n^2)<O(n^3)<O(2^n)<O(n!)$
 